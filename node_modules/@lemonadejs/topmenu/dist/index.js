if (!lemonade && typeof (require) === 'function') {
    var lemonade = require('lemonadejs');
}

if (! Contextmenu && typeof(require) === 'function') {
    var Contextmenu = require('@lemonadejs/contextmenu');
}

; (function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.Topmenu = factory();
}(this, (function () {

    const Topmenu = function(children, { onload, onchange }) {
        let self = this;

        // Current selection
        let currentIndex = null;

        const getElementPosition = function(child) {
            let root = self.el.children[0];
            for (let i = 0; i < root.children.length; i++) {
                let c = root.children[i];
                if (c === child) {
                    return i;
                }
            }
            return -1;
        }

        const select = function(e, s) {
            if (! self.menu.isClosed()) {
                let index = self.options.indexOf(s);
                if (index !== currentIndex) {
                    open(index);
                }
            }
        }

        const deselect = function() {
            if (self.options) {
                self.options.forEach(v => v.selected = false);
            }
        }

        const selectIndex = function(newIndex) {
            if (self.options) {
                let s = self.options[newIndex];
                if (s && ! s.disabled) {
                    deselect();
                    // Make it selected
                    s.selected = true;
                    // New index
                    currentIndex = newIndex;
                    // Focus
                    s.el.focus();
                }
            }
        }

        const open = function(index) {
            // Update cursor position
            selectIndex(index);
            let s = self.options[currentIndex];
            if (s && s.submenu) {
                let x = s.el.offsetLeft;
                let y = s.el.offsetTop + s.el.offsetHeight + 2;
                self.menu.open(s.submenu, x, y);
                s.expanded = true;
            }
        }

        const close = function() {
            self.menu.close(0);
            let s = self.options[currentIndex];
            if (s) {
                s.el.focus();
                s.expanded = false;
            }
        }

        const toggle = function(e, s) {
            if (s.submenu && ! s.disabled) {
                let index = self.options.indexOf(s);
                if (index === currentIndex && ! self.menu.isClosed()) {
                    close();
                } else {
                    open(index);
                }
                cancel(e);
            }
        }

        const findNextEnabledIndex = function(startIndex) {
            if (!self.options || self.options.length === 0) {
                return null;
            }
            
            let index = startIndex;
            let attempts = 0;
            const maxAttempts = self.options.length;
            
            while (attempts < maxAttempts) {
                if (index >= self.options.length) {
                    index = 0;
                }
                if (!self.options[index].disabled) {
                    return index;
                }
                index++;
                attempts++;
            }
            return null;
        };

        const findPreviousEnabledIndex = function(startIndex) {
            if (!self.options || self.options.length === 0) {
                return null;
            }
            
            let index = startIndex;
            let attempts = 0;
            const maxAttempts = self.options.length;
            
            while (attempts < maxAttempts) {
                if (index < 0) {
                    index = self.options.length - 1;
                }
                if (!self.options[index].disabled) {
                    return index;
                }
                index--;
                attempts++;
            }
            return null;
        };

        const adjustOptionProperties = function() {
            if (self.options) {
                self.options.forEach(v => {
                    v.haspopup = !!v.submenu;
                    v.expanded = false;

                    if (v.disabled) {
                        v.el.removeAttribute('tabindex');
                    } else {
                        v.el.setAttribute('tabindex', '0');
                    }
                })
            }
        };

        /**
         * Open a submenu programaticaly. Default 0
         * @param {number} index
         */
        self.open = function(index) {
            if (typeof index === 'undefined') {
                index = currentIndex;
            }
            if (! index) {
                index = 0;
            }

            let s = self.options[index];
            if (s) {
                open(index);
            }
        }

        onchange((prop) => {
            if (prop === 'options') {
                adjustOptionProperties();
            }
        });

        // Keyboard event
        onload(() => {
            self.el.addEventListener("focusin", function(e) {
                let index = getElementPosition(e.target);
                if (index !== -1) {
                    if (e.relatedTarget === self.menu.el) {
                        close();
                    } else {
                        selectIndex(index);
                    }
                }
            });

            self.el.addEventListener("focusout", function(e) {
                if (! (e.relatedTarget && self.el.contains(e.relatedTarget))) {
                    if (self.options[currentIndex]) {
                        self.options[currentIndex].selected = false;
                    }
                }
            });

            self.el.addEventListener("keydown", function(e) {
                let o = self.options;
                // Select top menu
                let select = null;

                if (e.key === 'Enter') {
                    toggle(e, o[currentIndex])
                } else if (e.key === 'ArrowLeft') {
                    select = findPreviousEnabledIndex(currentIndex - 1);
                } else if (e.key === 'ArrowRight') {
                    select = findNextEnabledIndex(currentIndex + 1);
                }

                if (select !== null) {
                    if (self.menu.isClosed()) {
                        selectIndex(select);
                    } else {
                        open(select);
                    }
                }
            });

            adjustOptionProperties();
        });

        const cancel = function(e) {
            e.preventDefault();
            e.stopImmediatePropagation();
        }

        return render => render`<div class="lm-topmenu" role="menubar" aria-orientation="horizontal" oncontextmenu="${cancel}">
            <div class="lm-topmenu-options" :loop="self.options">
                <div class="lm-topmenu-title" role="menuitem" data-disabled="{{self.disabled}}" data-selected="{{self.selected}}" tabindex="0" aria-haspopup="{{self.haspopup}}" aria-expanded="{{self.expanded}}" aria-label="{{self.title}}" onmousedown="${toggle}" onmouseenter="${select}">{{self.title}}</div>
            </div>
            <Contextmenu :ref="self.menu" :root="self.el" />
        </div>`
    }

    lemonade.setComponents({ Topmenu: Topmenu });

    // Register the web component
    lemonade.createWebComponent('topmenu', Topmenu);

    return function (root, options) {
        if (typeof (root) === 'object') {
            lemonade.render(Topmenu, root, options)
            return options;
        } else {
            return Topmenu.call(this, root)
        }
    }
})));