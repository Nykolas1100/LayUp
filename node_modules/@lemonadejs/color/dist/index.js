if (! lemonade && typeof (require) === 'function') {
    var lemonade = require('lemonadejs');
}

if (! Modal && typeof(require) === 'function') {
    var Modal = require('@lemonadejs/modal');
}

if (! Tabs && typeof(require) === 'function') {
    var Tabs = require('@lemonadejs/tabs');
}

; (function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.Color = factory();
}(this, (function () {

    // Dispatcher
    const Dispatch = function(method, type, options) {
        // Try calling the method directly if provided
        if (typeof method === 'function') {
            let a = Object.values(options);
            method(...a);
        } else if (this.tagName) {
            // Fallback: dispatch a custom event
            const event = new CustomEvent(type, {
                bubbles: true,
                cancelable: true,
                detail: options,
            });
            this.dispatchEvent(event);
        }
    }

    const defaultPalette =  [
        ["#ffebee", "#fce4ec", "#f3e5f5", "#e8eaf6", "#e3f2fd", "#e0f7fa", "#e0f2f1", "#e8f5e9", "#f1f8e9", "#f9fbe7", "#fffde7", "#fff8e1", "#fff3e0", "#fbe9e7", "#efebe9", "#fafafa", "#eceff1"],
        ["#ffcdd2", "#f8bbd0", "#e1bee7", "#c5cae9", "#bbdefb", "#b2ebf2", "#b2dfdb", "#c8e6c9", "#dcedc8", "#f0f4c3", "#fff9c4", "#ffecb3", "#ffe0b2", "#ffccbc", "#d7ccc8", "#f5f5f5", "#cfd8dc"],
        ["#ef9a9a", "#f48fb1", "#ce93d8", "#9fa8da", "#90caf9", "#80deea", "#80cbc4", "#a5d6a7", "#c5e1a5", "#e6ee9c", "#fff59d", "#ffe082", "#ffcc80", "#ffab91", "#bcaaa4", "#eeeeee", "#b0bec5"],
        ["#e57373", "#f06292", "#ba68c8", "#7986cb", "#64b5f6", "#4dd0e1", "#4db6ac", "#81c784", "#aed581", "#dce775", "#fff176", "#ffd54f", "#ffb74d", "#ff8a65", "#a1887f", "#e0e0e0", "#90a4ae"],
        ["#ef5350", "#ec407a", "#ab47bc", "#5c6bc0", "#42a5f5", "#26c6da", "#26a69a", "#66bb6a", "#9ccc65", "#d4e157", "#ffee58", "#ffca28", "#ffa726", "#ff7043", "#8d6e63", "#bdbdbd", "#78909c"],
        ["#f44336", "#e91e63", "#9c27b0", "#3f51b5", "#2196f3", "#00bcd4", "#009688", "#4caf50", "#8bc34a", "#cddc39", "#ffeb3b", "#ffc107", "#ff9800", "#ff5722", "#795548", "#9e9e9e", "#607d8b"],
        ["#e53935", "#d81b60", "#8e24aa", "#3949ab", "#1e88e5", "#00acc1", "#00897b", "#43a047", "#7cb342", "#c0ca33", "#fdd835", "#ffb300", "#fb8c00", "#f4511e", "#6d4c41", "#757575", "#546e7a"],
        ["#d32f2f", "#c2185b", "#7b1fa2", "#303f9f", "#1976d2", "#0097a7", "#00796b", "#388e3c", "#689f38", "#afb42b", "#fbc02d", "#ffa000", "#f57c00", "#e64a19", "#5d4037", "#616161", "#455a64"],
        ["#c62828", "#ad1457", "#6a1b9a", "#283593", "#1565c0", "#00838f", "#00695c", "#2e7d32", "#558b2f", "#9e9d24", "#f9a825", "#ff8f00", "#ef6c00", "#d84315", "#4e342e", "#424242", "#37474f"],
        ["#b71c1c", "#880e4f", "#4a148c", "#1a237e", "#0d47a1", "#006064", "#004d40", "#1b5e20", "#33691e", "#827717", "#f57f17", "#ff6f00", "#e65100", "#bf360c", "#3e2723", "#212121", "#263238"],
    ]

    const Grid = function(children, { onchange }) {
        const self = this;

        if (! self.palette) {
            self.palette = defaultPalette;
        }

        const select = (event) => {
            if (event.target.tagName === 'TD') {
                let color = event.target.getAttribute('data-value')

                // Remove current selected mark
                let selected = self.el.querySelector('.lm-color-selected');
                if (selected) {
                    selected.classList.remove('lm-color-selected');
                }

                // Mark cell as selected
                if (color) {
                    event.target.classList.add('lm-color-selected');
                    self.set(color);
                }
            }
        }

        self.constructRows = function (e) {
            let tbody = [];
            e.textContent = '';
            for (let j = 0; j < self.palette.length; j++) {
                let tr = document.createElement('tr');
                e.appendChild(tr);

                for (let i = 0; i < self.palette[j].length; i++) {
                    let color = self.palette[j][i];
                    let td = document.createElement('td');
                    td.setAttribute('data-value', color);
                    td.style.backgroundColor = color;
                    tr.appendChild(td);
                }
            }
        }

        onchange(property => {
            if (property === 'palette') {
                self.constructRows()
            }
        });

        return render => render`<div class="lm-color-grid" :palette="self.palette">
            <table cellpadding="7" cellspacing="0" onclick="${select}" :ref="self.table" :ready="self.constructRows"></table>
        </div>`
    }

    const Spectrum = function(children, { onload }) {
        let self = this;
        let context = null;

        let decToHex = function(num) {
            let hex = num.toString(16);
            return hex.length === 1 ? "0" + hex : hex;
        }
        let rgbToHex = function(r, g, b) {
            return "#" + decToHex(r) + decToHex(g) + decToHex(b);
        }

        onload(() => {
            context = self.canvas.getContext("2d", { willReadFrequently: true });
            draw();
        })

        // Drsaw
        const draw = function() {
            let g = context.createLinearGradient(0, 0, self.canvas.width, 0);
            // Create color gradient
            g.addColorStop(0,    "rgb(255,0,0)");
            g.addColorStop(0.15, "rgb(255,0,255)");
            g.addColorStop(0.33, "rgb(0,0,255)");
            g.addColorStop(0.49, "rgb(0,255,255)");
            g.addColorStop(0.67, "rgb(0,255,0)");
            g.addColorStop(0.84, "rgb(255,255,0)");
            g.addColorStop(1,    "rgb(255,0,0)");
            context.fillStyle = g;
            context.fillRect(0, 0, self.canvas.width, self.canvas.height);
            g = context.createLinearGradient(0, 0, 0, self.canvas.height);
            g.addColorStop(0,   "rgba(255,255,255,1)");
            g.addColorStop(0.5, "rgba(255,255,255,0)");
            g.addColorStop(0.5, "rgba(0,0,0,0)");
            g.addColorStop(1,   "rgba(0,0,0,1)");
            context.fillStyle = g;
            context.fillRect(0, 0, self.canvas.width, self.canvas.height);
        }

        // Moves the marquee point to the specified position
        const update = (e) => {
            let x;
            let y;
            let buttons = 1;
            if (e.type === 'touchmove') {
                x = e.changedTouches[0].clientX;
                y = e.changedTouches[0].clientY;
            } else {
                buttons = e.buttons;
                x = e.clientX;
                y = e.clientY;
            }

            if (buttons === 1) {
                let rect = self.el.getBoundingClientRect();
                let left = x - rect.left;
                let top = y - rect.top;
                // Get the color in this pixel
                let pixel = context.getImageData(left, top, 1, 1).data;
                // Position pointer
                self.point.style.left = left + 'px';
                self.point.style.top = top + 'px';
                // Return color
                self.set(rgbToHex(pixel[0], pixel[1], pixel[2]));
            }
        }

        return render => render`<div class="lm-color-hsl">
            <canvas width="240" height="140" :ref="self.canvas" onmousedown="${update}" onmousemove="${update}" ontouchmove="${update}"></canvas>
            <div class="lm-color-point" :ref="self.point"></div>
        </div>`;
    }

    const Color = function(children, { onchange, onload }) {
        let self = this;
        let value = null;

        const change = self.onchange;
        self.onchange = null;

        // Decide the type based on the size of the screen
        let autoType = self.type === 'auto';

        const applyValue = function(v) {
            if (self.value !== v) {
                self.value = v;
            }
        }

        const onopen = function(e) {
            self.open();
            // Open event
            Dispatch.call(self, self.onopen, 'open', {
                instance: self
            });
        }

        const onclose = function(modal, origin) {
            // Close event
            Dispatch.call(self, self.onclose, 'close', {
                instance: self,
                origin: origin,
            });
        }

        const update = function() {
            applyValue(value);
            self.close({ origin: 'button' });
        }

        const getInput = function() {
            let input = self.input;
            if (input && input.current) {
                input = input.current;
            } else {
                if (self.input) {
                    input = self.input;
                }
            }

            return input;
        }

        const events = {
            focusin: (e) => {
                if (self.modal && self.isClosed()) {
                    self.open();
                }
            },
            focusout: (e) => {
                if (self.modal && ! self.isClosed()) {
                    if (! (e.relatedTarget && self.modal.el.contains(e.relatedTarget))) {
                        self.modal.close({ origin: 'focusout' });
                    }
                }
            },
            click: (e) => {
                if (e.target.classList.contains('lm-color-input')) {
                    self.open();
                }
            },
            keydown: (e) => {
                if (self.modal) {
                    if (e.code === 'ArrowUp' || e.code === 'ArrowDown') {
                        if (self.isClosed()) {
                            self.open();
                        }
                    } else if (e.code === 'Enter') {
                        if (! self.isClosed()) {
                            update();
                        } else {
                            self.open();
                        }
                    } else if (e.code === 'Escape') {
                        if (! self.isClosed()) {
                            self.modal.close({origin: 'escape'});
                        }
                    }
                }
            }
        }

        const set = function(v) {
            value = v;
            // Close
            if (self.closeOnChange === true) {
                // Update value
                self.setValue(v);
                // Close modal
                self.close({ origin: 'select' });
            }
        }

        self.open = function(e) {
            if (self.modal) {
                if (autoType) {
                    self.type = window.innerWidth > 640 ? self.type = 'default' : 'picker';
                }
                value = self.value;
                // Table
                let table = self.grid.table;
                // Remove any selection
                let o = table.querySelector('.lm-color-selected');
                if (o) {
                    o.classList.remove('lm-color-selected');
                }
                // Selected
                o = table.querySelector('[data-value="'+self.value+'"]');
                if (o) {
                    o.classList.add('lm-color-selected');
                }
                // Open modal
                self.modal.open();
            }
        }

        /**
         * Close the modal
         */
        self.close = function(options) {
            if (self.modal) {
                if (options && options.origin) {
                    self.modal.close(options)
                } else {
                    self.modal.close({ origin: 'button' })
                }
            }
        }

        self.isClosed = function() {
            if (self.modal) {
                return self.modal.isClosed();
            }
        }

        self.reset = function() {
            self.setValue('');
            self.close({ origin: 'button' });
        }

        self.setValue = function(v) {
            self.value = value = v;
        }

        self.getValue = function() {
            return self.value;
        }

        self.onevent = function(e) {
            if (events[e.type]) {
                events[e.type](e);
            }
        }

        onchange(prop => {
            if (prop === 'value') {
                let input = getInput();
                if (input) {
                    input.value = self.value;
                    if (self.value) {
                        input.style.color = self.value;
                    } else {
                        input.style.color = '';
                    }
                }

                Dispatch.call(self, change, 'change', {
                    instance: self,
                    value: self.value,
                });
            }
        });

        // Input
        if (self.input === 'auto') {
            self.input = document.createElement('input');
            self.input.type = 'text';
        }

        onload(() => {
            if (self.type !== "inline") {
                // Create modal instance
                self.modal = {
                    closed: true,
                    onopen: onopen,
                    onclose: onclose,
                    focus: false,
                    position: 'absolute',
                    'auto-close': false,
                    'auto-adjust': true,
                };
                // Generate modal
                Modal(self.el, self.modal);
            }

            // Create input controls
            if (self.input && self.initInput !== false) {
                if (! self.input.parentNode) {
                    self.el.parentNode.insertBefore(self.input, self.el);
                }

                let input = getInput();
                if (input && input.tagName) {
                    input.classList.add('lm-input');
                    input.classList.add('lm-color-input');
                    input.addEventListener('click', events.click);
                    input.addEventListener('focusin', events.focusin);
                    input.addEventListener('focusout', events.focusout);
                    if (self.placeholder) {
                        input.setAttribute('placeholder', self.placeholder);
                    }
                    if (self.onChange) {
                        input.addEventListener('change', self.onChange);
                    }

                    // Retrieve the value
                    if (self.value) {
                        input.value = self.value;
                    } else if (input.value && input.value !== self.value) {
                        self.value = input.value;
                    }
                }
            }

            // Create event for focus out
            self.el.addEventListener("focusout", (e) => {
                let input = getInput();
                if (e.relatedTarget !== input && ! self.el.contains(e.relatedTarget)) {
                    self.close({ origin: 'focusout' });
                }
            });
        });

        return render => render`<div class="lm-color" :value="self.value">
            <div class="lm-color-options">
                <button type="button" onclick="${self.reset}">Reset</button>
                <button type="button" onclick="${update}">Done</button>
            </div>
            <lm-tabs selected="0" position="center" :ref="self.tabs">
                <div title="Grid"><${Grid} :palette="self.palette" :ref="self.grid" :set="${set}" /></div>
                <div title="Spectrum"><${Spectrum} :ref="self.spectrum" :set="${set}" /></div>
            </lm-tabs>
        </div>`;
    }

    lemonade.setComponents({ Color: Color });
    // Register the web component
    lemonade.createWebComponent('color', Color);

    return function (root, options) {
        if (typeof (root) === 'object') {
            lemonade.render(Color, root, options)
            return options;
        } else {
            return Color.call(this, root)
        }
    }
})));