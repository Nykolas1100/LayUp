if (! lemonade && typeof (require) === 'function') {
    var lemonade = require('lemonadejs');
}

; (function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.Tabs = factory();
}(this, (function () {

    class CustomEvents extends Event {
        constructor(type, props, options) {
            super(type, {
                bubbles: true,
                composed: true,
                ...options,
            });

            if (props) {
                for (const key in props) {
                    // Avoid assigning if property already exists anywhere on `this`
                    if (! (key in this)) {
                        this[key] = props[key];
                    }
                }
            }
        }
    }

    // Dispatcher
    const Dispatch = function(method, type, options) {
        // Try calling the method directly if provided
        if (typeof method === 'function') {
            let a = Object.values(options);
            return method(...a);
        } else if (this.tagName) {
            this.dispatchEvent(new CustomEvents(type, options));
        }
    }

    const extract = function(root, self) {
        if (! Array.isArray(self.data)) {
            self.data = [];
        }

        if (root.tagName) {
            for (let i = 0; i < root.children.length; i++) {
                self.data.push({
                    el: root.children[i],
                })
            }
        } else {
            root.forEach((child) => {
                self.data.push({
                    el: child.element,
                })
            });
        }
    }

    const sorting = function(el, options) {
        const obj = {};

        let dragElement = null;

        el.addEventListener('dragstart', function(e) {
            let target = e.target;
            if (target.nodeType === 3) {
                if (target.parentNode.getAttribute('draggable') === 'true') {
                    target = target.parentNode;
                } else {
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }
            }

            if (target.getAttribute('draggable') === 'true') {
                let position = Array.prototype.indexOf.call(target.parentNode.children, target);
                dragElement = {
                    element: target,
                    o: position,
                    d: position
                }
                target.style.opacity = '0.25';
                e.dataTransfer.setDragImage(target,0,0);
            }
        });

        el.addEventListener('dragover', function(e) {
            e.preventDefault();

            if (dragElement && getElement(e.target) && e.target.getAttribute('draggable') == 'true' && dragElement.element != e.target) {
                let element = e.target.clientWidth / 2 > e.offsetX ? e.target : e.target.nextSibling;
                e.target.parentNode.insertBefore(dragElement.element, element);
                dragElement.d = Array.prototype.indexOf.call(e.target.parentNode.children, dragElement.element);
            }
        });

        el.addEventListener('dragleave', function(e) {
            e.preventDefault();
        });

        el.addEventListener('dragend', function(e) {
            e.preventDefault();

            if (dragElement) {
                let element = dragElement.o < dragElement.d ? e.target.parentNode.children[dragElement.o] : e.target.parentNode.children[dragElement.o].nextSibling
                e.target.parentNode.insertBefore(dragElement.element, element);
                dragElement.element.style.opacity = '';
                dragElement = null;
            }
        });

        el.addEventListener('drop', function(e) {
            e.preventDefault();

            if (dragElement) {
                if (dragElement.o !== dragElement.d) {
                    if (typeof(options.ondrop) == 'function') {
                        options.ondrop(el, dragElement.o, dragElement.d, dragElement.element, e.target, e);
                    }
                }

                dragElement.element.style.opacity = '';
                dragElement = null;
            }
        });

        const getElement = function(element) {
            var sorting = false;

            function path (element) {
                if (element === el) {
                    sorting = true;
                }

                if (! sorting) {
                    path(element.parentNode);
                }
            }

            path(element);

            return sorting;
        }

        for (let i = 0; i < el.children.length; i++) {
            if (! el.children[i].hasAttribute('draggable')) {
                el.children[i].setAttribute('draggable', 'true');
            }
        }

        return el;
    }

    const Tabs = function(children, { onchange, onload }) {
        let self = this

        // Event
        let change = self.onchange;
        self.onchange = null;

        // Add new tab
        let createButton;

        // Get the references from the root web component
        let root;
        let template = '';
        if (this.tagName) {
            root = this;
        } else {
            // References from LemonadeJS
            if (typeof(children) === 'string') {
                // Version 4
                template = children;
            } else if (children && children.length) {
                // Version 5
                root = children;
            }
        }

        if (root) {
            extract(root, self);
        }

        // Process the data
        if (self.data) {
            for (let i = 0; i < self.data.length; i++) {
                if (! self.data[i].el) {
                    // Create element
                    self.data[i].el = document.createElement('div');
                    // Create from content
                    if (self.data[i].content) {
                        self.data[i].el.innerHTML = self.data[i].content;
                    }
                }
            }
        }

        let props = ['title', 'selected', 'data-icon'];

        const select = function(index) {
            // Make sure the index is a number
            index = parseInt(index);
            // Do not select tabs that does not exist
            if (index >= 0 && index < self.data.length) {
                for (let i = 0; i < self.root.children.length; i++) {
                    self.headers.children[i].classList.remove('selected');
                    self.root.children[i].classList.remove('selected');
                }
                self.headers.children[index].classList.add('selected');
                self.root.children[index].classList.add('selected');
            }
        }

        const init = function(selected) {
            let tabs = [];

            for (let i = 0; i < self.data.length; i++) {
                // Extract meta information from the DOM
                if (props) {
                    props.forEach((prop) => {
                        let short = prop.replace('data-', '');
                        if (! self.data[i][short]) {
                            let ret = self.data[i].el.getAttribute(prop);
                            if (ret != null) {
                                self.data[i][short] = ret;
                            }
                        }
                    });
                }
                // Create tabs object
                tabs[i] = {
                    title: self.data[i].title,
                }
                // Which one is selected by default
                if (self.data[i].selected) {
                    selected = i;
                }
                if (self.data[i].icon) {
                    tabs[i].icon = self.data[i].icon;
                }

                self.root.appendChild(self.data[i].el);
            }

            // Create headers
            self.tabs = tabs;

            // Default selected
            if (typeof(selected) !== 'undefined') {
                self.selected = selected;
            }

            if (props) {
                // Add create new tab button
                if (createButton) {
                    self.headers.appendChild(createButton);
                }
                // Add sorting
                sorting(self.el.firstChild.firstChild, {
                    ondrop: (el, fromIndex, toIndex) => {
                        // Remove the item from its original position
                        const [movedItem] = self.data.splice(fromIndex, 1);
                        // Insert it into the new position
                        self.data.splice(toIndex, 0, movedItem);
                        // Make sure correct order
                        for (let i = 0; i < self.data.length; i++) {
                            self.root.appendChild(self.data[i].el);
                        }
                        // Select new position
                        self.selected = toIndex;
                        // Dispatch event
                        Dispatch.call(self, self.onchangeposition, 'changeposition', {
                            instance: self,
                            fromIndex: fromIndex,
                            toIndex: toIndex,
                        });
                    }
                })
            }

            props = null;
        }

        const create = function() {
            // Create a new item
            self.create({ title: 'Untitled' }, null, true);
        }

        const open = function(e) {
            if (e.target.tagName === 'LI') {
                // Avoid select something already selected
                let index = Array.prototype.indexOf.call(e.target.parentNode.children, e.target);
                if (index !== self.selected) {
                    self.selected = index;
                }
            }
        }

        const keydown = function(e, s) {
            let index = null;
            if (e.key === 'Enter') {
                self.click(e, s);
            } else if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') {
                index = self.selected - 1;
                if (index < 0) {
                    index = 0;
                }
            } else if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {
                index = self.selected + 1;
                if (index > self.tabs.length-1) {
                    index = self.tabs.length-1;
                }
            }

            // Make selection
            if (index !== null) {
                self.tabs[index].el.focus();
            }
        }

        onload(() => {
            if (template) {
                extract(self.root, self);
            }

            init(self.selected || 0);
        })

        onchange((property) => {
            if (property === 'selected') {
                select(self.selected);

                Dispatch.call(self, self.onopen, 'open', {
                    instance: self,
                    selected: self.selected,
                });

                Dispatch.call(self, change, 'change', {
                    instance: self,
                    value: self.selected,
                });
            }
        })

        self.open = function (index) {
            self.selected = index;
        }

        self.create = function(item, position, select) {
            // Create element
            if (typeof(item) !== 'object') {
                console.error('Item must be an object');
            } else {

                let ret = Dispatch.call(self, self.onbeforecreate, 'beforecreate', {
                    instance: self,
                    item: item,
                    position: position,
                });

                if (ret === false) {
                    return false;
                }

                // Create DOM
                item.el = document.createElement('div');
                // Create from content
                if (item.content) {
                    item.el.innerHTML = item.content;
                }

                // Add the new item in the end
                if (typeof(position) === 'undefined' || position === null) {
                    // Mew item
                    position = self.data.length;
                    // Add in the end
                    self.data.push(item);
                } else {
                    self.data.splice(position, 0, item);
                }
                // New position
                if (select) {
                    // Refresh
                    init(self.data.indexOf(item));
                } else {
                    init(self.selected);
                }

                self.tabs.forEach(item => {
                    item.el.setAttribute('draggable', 'true');
                })

                Dispatch.call(self, self.oncreate, 'create', {
                    instance: self,
                    item: item,
                    position: position,
                });
            }
        }

        self.allowCreate = !! self.allowCreate;

        return render => render`<div class="lm-tabs" data-position="{{self.position}}" data-round="{{self.round}}">
            <div role="tabs" class="lm-tabs-headers">
                <ul :ref="self.headers" :loop="self.tabs" :selected="self.selected" onclick="${open}" onkeydown="${keydown}" onfocusin="${open}"><li class="lm-tab" tabindex="0" role="tab" data-icon="{{self.icon}}">{{self.title}}</li></ul>
                <div data-visible="{{self.allowCreate}}" class="lm-tabs-insert-button" role="insert-tab" onclick="${create}">add</div>
            </div>
            <div :ref="self.root" class="lm-tabs-content">${template}</div>
        </div>`
    }

    lemonade.setComponents({ Tabs: Tabs });

    lemonade.createWebComponent('tabs', Tabs);

    return function (root, options) {
        if (typeof (root) === 'object') {
            if (typeof(options) !== 'object') {
                options = {};
            }
            // Extract DOM references
            extract(root, options);
            // Create the modal
            lemonade.render(Tabs, root, options);
            // Return self
            return options;
        } else {
            return Tabs.call(this);
        }
    };
})));