if (! lemonade && typeof(require) === 'function') {
    var lemonade = require('lemonadejs');
}

if (! Modal && typeof (require) === 'function') {
    var Modal = require('@lemonadejs/modal');
}

; (function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.Contextmenu = factory();
}(this, (function () {

    class CustomEvents extends Event {
        constructor(type, props, options) {
            super(type, {
                bubbles: true,
                composed: true,
                ...options,
            });

            if (props) {
                for (const key in props) {
                    // Avoid assigning if property already exists anywhere on `this`
                    if (! (key in this)) {
                        this[key] = props[key];
                    }
                }
            }
        }
    }

    // Dispatcher
    const Dispatch = function(method, type, options) {
        // Try calling the method directly if provided
        if (typeof method === 'function') {
            let a = Object.values(options);
            return method(...a);
        } else if (this.tagName) {
            this.dispatchEvent(new CustomEvents(type, options));
        }
    }

    // Get the coordinates of the action
    const getCoords = function(e) {
        let x;
        let y;

        if (e.changedTouches && e.changedTouches[0]) {
            x = e.changedTouches[0].clientX;
            y = e.changedTouches[0].clientY;
        } else {
            x = e.clientX;
            y = e.clientY;
        }

        return [x,y];
    }

    const Item = function() {
        let self = this;

        self.onload = function() {
            if (typeof(self.render) === 'function') {
                self.render.call(self, self.el);
            }
        }

        // Initialize expanded state
        self.expanded = false;

        if (self.type === 'line' || self.type === 'divisor') {
            return `<hr role="separator" />`;
        } else if (self.type === 'inline') {
            return `<div></div>`;
        } else {
            return `<div class="lm-menu-item" role="menuitem" data-disabled="{{self.disabled}}" data-cursor="{{self.cursor}}" data-icon="{{self.icon}}" title="{{self.tooltip}}" data-submenu="${!!self.submenu}" aria-haspopup="${!!self.submenu}" aria-expanded="{{self.expanded}}" aria-label="{{self.title}}" tabindex="-1" onmouseup="self.parent.mouseUp" onmouseenter="self.parent.mouseEnter" onmouseleave="self.parent.mouseLeave">
                <span>{{self.title}}</span> <div>{{self.shortcut}}</div>
            </div>`;
        }
    }

    const Create = function() {
        let self = this;

        // Delay on open
        let delayTimer;
        // Save the position of this modal
        let index = self.parent.modals.length;

        // Blank options
        self.options = [];

        // Close handler
        self.onclose = function() {
            // Reset any cursor
            resetCursor.call(self);
            // Parent
            if (typeof(self.parent.onclose) === 'function') {
                self.parent.onclose(self.parent, self);
            }
        }

        self.onopen = function() {
            // Parent
            if (typeof(self.parent.onopen) === 'function') {
                self.parent.onopen(self.parent, self);
            }
        }

        /**
         * Close the modal
         */
        self.close = function() {
            // Close modals with higher level
            self.parent.close(index);
        }

        /**
         * Open submenu handler
         * @param {object} s
         * @param {boolean} cursor - Activate the first item
         */
        self.open = function(s, cursor) {
            if (s.submenu) {
                // Get the modal in the container of modals
                let current = self.parent.modals[index+1];
                // Do not exist yet, create it.
                if (! current) {
                    // Modal needs to be created
                    current = self.parent.create();
                }
                // Get the parent from this one
                let parent = self.parent.modals[index];
                // Update modal content
                if (current.options !== s.submenu) {
                    // Close modals with higher level
                    current.options = s.submenu;
                    // Close other modals
                    self.parent.close(index+1);
                }
                // Update the selected modal
                self.parent.modalIndex = index+1;
                let rect = parent.modal.el.getBoundingClientRect();
                // Update modal
                current.modal.open();

                // Calculate initial position using item's actual screen position (accounts for scroll)
                let itemRect = s.el.getBoundingClientRect();
                let submenuWidth = 250;
                let submenuTop = itemRect.y;
                let submenuLeft = rect.x + rect.width - 2; // Position to the right of parent

                // Check if parent was positioned to the left (has negative margin or is on left side)
                let parentOpenedLeft = parent.openedLeft || false;

                // Check horizontal space
                let spaceOnRight = window.innerWidth - (rect.x + rect.width);
                let spaceOnLeft = rect.x;

                // Determine which side to open the submenu
                let openLeft = parentOpenedLeft; // Follow parent's direction by default

                // If parent opened to right, check if we still have space
                if (!parentOpenedLeft && spaceOnRight < submenuWidth + 10) {
                    // Not enough space on right, switch to left
                    openLeft = true;
                }
                // If parent opened to left, check if we still have space on left
                if (parentOpenedLeft && spaceOnLeft < submenuWidth + 10) {
                    // Not enough space on left, switch to right if possible
                    if (spaceOnRight >= submenuWidth + 10) {
                        openLeft = false;
                    }
                }

                if (openLeft) {
                    // Position to the left of parent menu
                    submenuLeft = rect.x - submenuWidth + 2;
                    // Ensure it doesn't go off the left edge
                    if (submenuLeft < 10) {
                        submenuLeft = 10;
                    }
                    current.openedLeft = true;
                } else {
                    current.openedLeft = false;
                }

                // Set position
                current.modal.top = submenuTop;
                current.modal.left = submenuLeft;

                // Adjust vertical position after render
                queueMicrotask(() => {
                    let submenuEl = current.modal.el;
                    let submenuRect = submenuEl.getBoundingClientRect();

                    // Check if submenu goes off the bottom
                    if (submenuRect.bottom > window.innerHeight - 10) {
                        let overflow = submenuRect.bottom - (window.innerHeight - 10);
                        let newTop = submenuTop - overflow;
                        // Don't go above the top of the screen
                        if (newTop < 10) {
                            newTop = 10;
                        }
                        current.modal.top = newTop;
                    }
                });

                // Keep current item for each modal
                current.item = s;
                s.expanded = true;

                // Activate the cursor
                if (cursor === true) {
                    // Place cursor in the first position
                    current.options[0].cursor = true;
                    // Position cursor
                    current.cursor = 0;
                }

                onopen(current, s.submenu)
            } else {
                // Close modals with higher level
                self.parent.close(index+1);
            }
        }

        // Mouse open
        self.mouseUp = function(e, s) {
            if (typeof(s.onclick) === 'function') {
                s.onclick.call(s, e, s.el);
            }
            if (! s.submenu) {
                self.close();
            }
        }

        self.mouseEnter = function(e, s) {
            if (delayTimer) {
                clearTimeout(delayTimer);
            }
            delayTimer = setTimeout(function() {
                self.open(s);
            }, 200);
        }

        self.mouseLeave = function(e, s) {
            if (delayTimer) {
                clearTimeout(delayTimer);
            }
        }

        let template = `<lm-modal :overflow="true" :closed="true" :ref="self.modal" :responsive="false" :auto-adjust="true" :focus="false" :layers="false" :onopen="self.onopen" :onclose="self.onclose">
            <div class="lm-menu-submenu" role="menu" aria-orientation="vertical">
                <Item :loop="self.options" />
            </div>
        </lm-modal>`;

        return lemonade.element(template, self, { Item: Item });
    }

    const findNextEnabledCursor = function(startIndex, direction) {
        if (!this.options || this.options.length === 0) {
            return null;
        }
        
        let cursor = startIndex;
        let attempts = 0;
        const maxAttempts = this.options.length;
        
        while (attempts < maxAttempts) {
            if (direction) {
                // Down
                if (cursor >= this.options.length) {
                    cursor = 0;
                }
            } else {
                // Up
                if (cursor < 0) {
                    cursor = this.options.length - 1;
                }
            }
            
            let item = this.options[cursor];
            if (item && !item.disabled && item.type !== 'line') {
                return cursor;
            }
            
            cursor = direction ? cursor + 1 : cursor - 1;
            attempts++;
        }
        return null;
    };

    const setCursor = function(direction) {
        let cursor = null;

        if (typeof(this.cursor) !== 'undefined') {
            if (! direction) {
                // Up
                cursor = findNextEnabledCursor.call(this, this.cursor - 1, false);
            } else {
                // Down
                cursor = findNextEnabledCursor.call(this, this.cursor + 1, true);
            }
        }

        // Remove the cursor
        if (cursor === null) {
            if (direction) {
                cursor = findNextEnabledCursor.call(this, 0, true);
            } else {
                cursor = findNextEnabledCursor.call(this, this.options.length - 1, false);
            }
        } else if (typeof(this.cursor) !== 'undefined') {
            this.options[this.cursor].cursor = false;
        }

        // Add the cursor if found
        if (cursor !== null) {
            this.options[cursor].cursor = true;
            this.cursor = cursor;
            return true;
        }

        return false;
    }

    /**
     * Reset the cursor for a contextmenu
     */
    const resetCursor = function() {
        // Contextmenu modal
        let item = this.options[this.cursor];
        // Cursor is found so reset it
        if (typeof(item) !== 'undefined') {
            // Remove the cursor style
            item.cursor = false;
            // Delete reference index
            delete this.cursor;
        }
    }

    /**
     * Go through all items of a menu
     * @param s
     * @param options
     */
    const onopen = function(s, options) {
        // Onopen
        for (let i = 0; i < options.length; i++) {
            if (typeof(options[i].onopen) === 'function') {
                options[i].onopen(s);
            }
        }
    }

    const Contextmenu = function(children, { onload }) {
        let self = this;

        // Container for all modals
        self.modals = [];
        self.modalIndex = 0;

        self.create = function() {
            // Create a new self for each modal
            let s = {
                parent: self,
            };
            // Render the modal inside the main container
            lemonade.render(Create, self.el, s);
            // Add the reference of the modal in a container#
            self.modals.push(s);
            // Return self
            return s;
        }

        self.isClosed = function() {
            return self.modals[0].modal.closed === true;
        }

        self.openAt = function(a, b) {
            let x, y;
            if (a instanceof Event || (a && a.clientX !== undefined)) {
                // openAt(event)
                x = a.clientX;
                y = a.clientY;
            } else {
                // openAt(x, y)
                x = a;
                y = b;
            }
            self.open(self.options, x, y, true);
        };

        self.open = function(options, x, y, adjust) {
            // Get the main modal
            let menu = self.modals[0];
            // Reset cursor
            resetCursor.call(menu);
            // Define new position
            menu.modal.top = y;
            menu.modal.left = x;
            // Open
            menu.modal.open();
            // If the modal is open and the content is different from what is shown. Close modals with higher level
            self.close(1);
            // Update the data
            if (options && menu.options !== options) {
                // Refresh content
                menu.options = options;
            }
            onopen(self, options);

            // Adjust position to respect mouse cursor after auto-adjust
            // Use queueMicrotask to ensure it runs after the modal's auto-adjust
            if (adjust === true) {
                queueMicrotask(() => {
                    let modalEl = menu.modal.el;
                    let rect = modalEl.getBoundingClientRect();
                    let marginLeft = parseFloat(modalEl.style.marginLeft) || 0;
                    let marginTop = parseFloat(modalEl.style.marginTop) || 0;

                    // Check if horizontal adjustment was applied (margin is non-zero)
                    if (marginLeft !== 0) {
                        // Position modal so its right edge is at x - 1 (cursor 1px to the right of modal)
                        // Formula: left + margin + width = x - 1, where left = x
                        // Therefore: margin = -width - 1
                        let newMarginLeft = -rect.width - 1;
                        // Check if this would push modal off the left edge
                        let newLeft = x + newMarginLeft;
                        if (newLeft < 10) {
                            // Keep a 10px margin from the left edge
                            newMarginLeft = 10 - x;
                        }
                        modalEl.style.marginLeft = newMarginLeft + 'px';
                    }

                    // Check if vertical adjustment was applied (margin is non-zero)
                    if (marginTop !== 0) {
                        // Position modal so its bottom edge is at y - 1 (cursor 1px below modal)
                        // Formula: top + margin + height = y - 1, where top = y
                        // Therefore: margin = -height - 1
                        let newMarginTop = -rect.height - 1;
                        // Check if this would push modal off the top edge
                        let newTop = y + newMarginTop;
                        if (newTop < 10) {
                            // Keep a 10px margin from the top edge
                            newMarginTop = 10 - y;
                        }
                        modalEl.style.marginTop = newMarginTop + 'px';
                    }
                });
            }
            // Focus
            self.el.classList.add('lm-menu-focus');
            // Focus on the contextmenu
            self.el.focus();
        }

        self.close = function(level) {
            // Close all modals from the level specified
            self.modals.forEach(function(menu, k) {
                if (k >= level) {
                    if (menu.item) {
                        menu.item.expanded = false;
                        menu.item = null;
                    }
                    menu.openedLeft = false;
                    menu.modal.close();
                }
            });
            // Keep the index of the modal that is opened
            self.modalIndex = level ? level - 1 : 0;

            // Close event
            if (level === 0) {
                self.el.classList.remove('lm-menu-focus');

                Dispatch.call(self, self.onclose, 'close', {
                    instance: self,
                });
            }
        }

        onload(() => {
            // Create first menu
            self.create();

            // Create event for focus out
            self.el.addEventListener("focusout", (e) => {
                if (! (e.relatedTarget && (self.el.contains(e.relatedTarget) || self.root?.contains(e.relatedTarget)))) {
                    self.close(0);
                }
            });

            // Keyboard event
            self.el.addEventListener("keydown", function(e) {
                // Menu object
                let menu = self.modals[self.modalIndex];
                // Modal must be opened
                if (! menu.modal.closed) {
                    // Something happens
                    let ret = false;
                    // Control
                    if (e.key === 'ArrowLeft') {
                        if (self.modalIndex > 0) {
                            // Close modal
                            menu.close();
                            // Action happened
                            ret = true;
                        }
                    } else if (e.key === 'ArrowRight') {
                        // Get the selected cursor
                        let item = menu.options[menu.cursor];
                        // Open submenu
                        if (typeof (item) !== 'undefined') {
                            // Open submenu in case that exists
                            if (item.submenu && !item.disabled) {
                                // Open modal
                                menu.open(item, true);
                                // Action happened
                                ret = true;
                            }
                        }
                    } else if (e.key === 'ArrowUp') {
                        ret = setCursor.call(menu, 0);
                    } else if (e.key === 'ArrowDown') {
                        ret = setCursor.call(menu, 1);
                    } else if (e.key === 'Enter') {
                        // Contextmenu modal
                        let item = menu.options[menu.cursor];
                        // Cursor is found so reset it
                        if (typeof(item) !== 'undefined') {
                            // Execute action
                            if (typeof (item.onclick) === 'function') {
                                item.onclick.call(item, e, item.el);
                            }
                            // Open sub menu in case exists
                            if (item.submenu) {
                                // Open menu
                                menu.open(item, true);
                                // Action happened
                                ret = true;
                            } else {
                                // Close all menu
                                self.close(0);
                                // Action happened
                                ret = true;
                            }
                        }
                    } else if (e.key === 'Escape') {
                        self.close(0);
                    }

                    // Something important happen so block any progression
                    if (ret === true) {
                        e.preventDefault();
                        e.stopImmediatePropagation();
                    }
                }
            });

            if (! self.root) {
                if (self.tagName) {
                    self.root = self.el.parentNode.parentNode;
                } else {
                    self.root = self.el.parentNode;
                }
            }

            // Parent
            self.root.addEventListener("contextmenu", function(e) {
                if (Array.isArray(self.options) && self.options.length) {
                    let [x, y] = getCoords(e);
                    self.open(self.options, x, y, true);
                    e.preventDefault();
                    e.stopImmediatePropagation();
                }
            });
        });

        return `<div class="lm-menu" role="menu" aria-orientation="vertical" tabindex="0"></div>`;
    }

    lemonade.setComponents({ Contextmenu: Contextmenu });

    lemonade.createWebComponent('contextmenu', Contextmenu);

    return function (root, options) {
        if (typeof (root) === 'object') {
            lemonade.render(Contextmenu, root, options)
            return options;
        } else {
            return Contextmenu.call(this, root)
        }
    }
})));