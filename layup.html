<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web-Based Layup Parser</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: sans-serif;
        }

        .split {
            display: flex;
            height: 100vh;
            width: 100%;
            overflow: hidden;
            position: relative;
        }

        .pane {
            flex: 1;
            overflow: auto;
            min-width: 0;
            padding: 10px;
            box-sizing: border-box;
        }

        .split::after {
            content: "";
            position: absolute;
            top: 0;
            bottom: 0;
            left: 50%;          /* middle of the container */
            width: 2px;         /* thickness of the divider */
            background-color: #ccc;  /* color of the divider */
            transform: translateX(-50%); /* center it exactly at 50% */
            pointer-events: none;      /* allows clicks to pass through */
        }

        .left {
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .right {
            display: flex;
            flex-direction: column;
            overflow: auto;
        }

        #output {
            flex: 1 1 auto;
            overflow: auto;
        }

        pre { 
            background-color: #eee; 
            padding: 10px; 
            border: 1px solid #ccc; 
            white-space: pre-wrap; 
            word-wrap: break-word; 
        }

        button {
            padding: 10px 15px;
            margin-top: 10px;
            font-size: 16px;
        }

        #codeInput {
            width: 100%;
            min-height: 100px;
            padding: 10px;
            box-sizing: border-box;
            font-family: monospace;
            resize: vertical;
        }

        #spreadsheet {
            flex: 1 1 auto;
        }

    </style>
    
<script src="https://cdn.jsdelivr.net/npm/jsuites@4/dist/jsuites.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsuites@4/dist/jsuites.min.css" type="text/css" />

<script src="https://cdn.jsdelivr.net/npm/jspreadsheet-ce@4/dist/index.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jspreadsheet-ce@4/dist/jspreadsheet.min.css" type="text/css" />

</head>
<body>
    <h1>Layup Parser</h1>

    <div class="split">
        <!-- LEFT: Code -->
        <div class="pane left">
            <label for="codeInput">Enter Code:</label>
            <textarea id="codeInput"></textarea>

            <button id="parseButton">Parse Code</button>
            <button id="downloadCsvButton">Download CSV</button>

            <h2>Output</h2>
            <pre id="output">Enter code and press 'Parse Code' to see the results here.</pre>
        </div>

        <!-- RIGHT: CSV Viewer -->
        <div class="pane right">
            <h2>CSV Output</h2>
            <div id="spreadsheet"></div>
        </div>
    </div>

    <script src="./dist/bundle.js"></script>
    <script type="module">
        import { AST } from "./layupAST.js";
        const parseButton = document.getElementById('parseButton');
        const downloadCSVButton = document.getElementById('downloadCsvButton');
        const codeInput = document.getElementById('codeInput');
        const outputDiv = document.getElementById('output');
        const symbolTable = {};
        let csv = null;
        let sheet;

        parseButton.addEventListener('click', () => {
            const code = codeInput.value;

            try {
                const result = window.parseCode(code);

                if (result.error) {
                    outputDiv.textContent = "Error: " + result.error;
                    console.error(result.details);
                    csv = [];
                    window.lastAST = [];
                    return;
                }

                outputDiv.textContent =
                    "AST:\n" + JSON.stringify(result.ast, null, 2) +
                    "\n\nOutput:\n" + result.output.toString() +
                    "\n\nEnvironment:\n" + JSON.stringify(result.env, null, 2);

                csv = result.output;
                window.lastAST = result.ast;

                Object.keys(symbolTable).forEach(key => delete symbolTable[key]);
                const cells = parserOutputToSheet(result.output, result.ast);

                if (!sheet) {
                    sheet = jspreadsheet(document.getElementById("spreadsheet"), {
                        data: [[]],
                        minDimensions: [10, 20]
                    });
                }

                // clear sheet
                sheet.setData([[]]);

                // write cells
                Object.entries(cells).forEach(([key, value]) => {
                    const [row, col] = key.split(',').map(Number);
                    sheet.setValueFromCoords(col, row, value);
                });

            } catch (e) {
                outputDiv.textContent = "Exception: " + e.message;
                console.error(e);
                csv = [];
                window.lastAST = [];
            }
});

        function csvArrayToObjects(csvArray) {
            if (csvArray.length === 0) return [];
            const headers = csvArray[0];
            return csvArray.slice(1).map(row => {
                const obj = {};
                row.forEach((val, i) => obj[headers[i] ?? `col${i+1}`] = val);
                return obj;
            });
        }

        function colToIndex(col) {
            let idx = 0;
            for (let i = 0; i < col.length; i++) {
                idx = idx * 26 + (col.charCodeAt(i) - 64);
            }
            return idx - 1;
        }

        function rowToIndex(row) {
            return row - 1;
        }

        function cellAddress(row, col) {
            const letter = String.fromCharCode(65 + col);
            return `${letter}${row + 1}`;
        }

        function exprToFormula(expr, symbolTable, rowOffset = 0, colOffset = 0) {
            // Gap case
            if (!expr || expr instanceof AST.Gap) {
                return "";
            }
            // Number literal
            if ("value" in expr && typeof expr.value === "number") {
                return expr.value.toString();
            }

            // Variable
            if ("name" in expr && typeof expr.name === "string") {
                const baseAddress = symbolTable[expr.name];
                if (!baseAddress) return "#NAME?";
                
                // If no offset, just return the base
                if (rowOffset === 0 && colOffset === 0) return baseAddress;

                // Parse "B1" -> col "B", row 1
                const match = baseAddress.match(/([A-Z]+)([0-9]+)/);
                if (match) {
                    const colPart = match[1];
                    const rowPart = parseInt(match[2]);
                    
                    // Apply column offset
                    const colIndex = colToIndex(colPart) + colOffset;
                    const newCol = String.fromCharCode(65 + colIndex);
                    
                    // Apply row offset
                    const newRow = rowPart + rowOffset;
                    
                    return `${newCol}${newRow}`;
                }
                return baseAddress;
            }

            // Binary expressions
            if ("left" in expr && "right" in expr) {
                const left = exprToFormula(expr.left, symbolTable, rowOffset, colOffset);
                const right = exprToFormula(expr.right, symbolTable, rowOffset, colOffset);

                switch (expr.constructor.name) {
                    case "Plus": return `(${left}+${right})`;
                    case "Minus": return `(${left}-${right})`;
                    case "Times": return `(${left}*${right})`;
                    case "Div": return `(${left}/${right})`;
                }
            }

            throw new Error("Unsupported expression type: " + JSON.stringify(expr));
        }

        function parserOutputToSheet(outputValues, ast) {
            const cells = {}; 
            const unwrap = (v) => {
                if (v === null || v === undefined) return v;
                return (typeof v === 'object' && 'value' in v) ? v.value : v;
            };

            let cursorRow = 0;

            ast.forEach((node, index) => {
                if (node instanceof AST.Gap) {
                    cursorRow += 1;
                    return;
                }
                if (outputValues[index] instanceof AST.Gap) {
                    return;
                }
                
                let val = unwrap(outputValues[index]);
                const key = node.key ?? "";
                
                let startCol = 0;
                let startRow = cursorRow;

                // Redefinition
                if (key && symbolTable[key]) {
                    const addr = symbolTable[key];
                    const match = addr.match(/([A-Z]+)([0-9]+)/);
                    if (match) {
                        startRow = parseInt(match[2]) - 1; 
                    }
                } 
                // Explicit location
                else if (node.location) {
                    startCol = colToIndex(node.location.col);
                    startRow = rowToIndex(node.location.row);
                }

                // Point to head cell
                if (key) {
                    symbolTable[key] = cellAddress(startRow, startCol + 1);
                }

                // Array case
                if (Array.isArray(val)) {
                    val.forEach((_, i) => {
                        const currentCol = startCol + 1 + i; // Shift right for each array element

                        if (i === 0 && key) {
                            cells[`${startRow},${startCol}`] = key;
                        }
                        
                        let formula;
                        if (node.valueExpr && Array.isArray(node.valueExpr.value) && node.valueExpr.value[i]) {
                            // Literal array
                            formula = exprToFormula(node.valueExpr.value[i], symbolTable, 0, 0);
                        } else {
                            // Derived array - pass column offset instead of row offset
                            formula = exprToFormula(node.valueExpr, symbolTable, 0, i);
                        }

                        cells[`${startRow},${currentCol}`] = "=" + formula;
                    });

                    cursorRow += 1;
                } else {
                    // Scalar Case
                    cells[`${startRow},${startCol}`] = key;
                    const formula = exprToFormula(node.valueExpr, symbolTable, 0);
                    cells[`${startRow},${startCol + 1}`] = "=" + formula;
                    
                    if (!node.location && !(key && startRow < cursorRow)) {
                        cursorRow += 1;
                    }
                }
            });

            return cells;
        }

        function cellsToCSV(cells) {
            let maxRow = 0;
            let maxCol = 0;

            Object.keys(cells).forEach(key => {
                const [row, col] = key.split(',').map(Number);
                maxRow = Math.max(maxRow, row);
                maxCol = Math.max(maxCol, col);
            });

            const grid = Array.from({ length: maxRow + 1 }, () =>
                Array.from({ length: maxCol + 1 }, () => "")
            );

            Object.entries(cells).forEach(([key, value]) => {
                const [row, col] = key.split(',').map(Number);
                grid[row][col] = value;
            });

            return grid;
        }

        downloadCSVButton.addEventListener("click", () => {
            if (!csv || !window.lastAST) {
                alert("Nothing to export.");
                return;
            }

            const cells = parserOutputToSheet(csv, window.lastAST);
            const grid = cellsToCSV(cells);

            const csvContent = grid
                .map(row =>
                    row.map(cell =>
                        typeof cell === "string" && cell.includes(",")
                            ? `"${cell}"`
                            : cell
                    ).join(",")
                )
                .join("\n");

            const blob = new Blob([csvContent], { type: "text/csv" });
            const url = URL.createObjectURL(blob);

            const a = document.createElement("a");
            a.href = url;
            a.download = "output.csv";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

    </script>
</body>
</html>